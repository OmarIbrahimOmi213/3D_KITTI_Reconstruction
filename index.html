<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Car Animation with Video Controls - Split Screen</title>
  <style>
  #mainTitle {
    font-size: 28px; /* Adjust size as needed */
    font-weight: 600; /* Semi-bold for a modern feel */
    color: #333; /* Dark grey for good contrast */
    text-align: center;
    margin-top: 20px; /* Space from the top of the viewport */
    margin-bottom: 25px; /* Space below the title, before tabs */
    letter-spacing: 0.5px; /* Slight letter spacing */
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; /* Consistent with body */
    padding: 5px 0;
    /* Optional: A subtle bottom border or shadow for more definition */
    /* border-bottom: 1px solid #ddd; */
    /* text-shadow: 0 1px 2px rgba(0,0,0,0.1); */
  }
  body {
    margin: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    /* justify-content: center; REMOVE THIS IF YOU WANT TITLE AT TOP */
    min-height: 100vh;
    background-color: #f0f0f0;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    padding-top: 0; /* Reset body padding-top if title handles top spacing */
  }

  #tabsContainer {
    margin-bottom: 15px;
    display: flex;
    gap: 10px;
  }

  .tab-button {
    padding: 8px 15px;
    font-size: 14px;
    font-weight: 500;
    border: 1px solid #ccc;
    background-color: #fff;
    color: #333;
    border-radius: 6px;
    cursor: pointer;
    transition: background-color 0.2s ease, color 0.2s ease, border-color 0.2s ease;
  }
  .tab-button:hover {
    background-color: #e9e9e9;
    border-color: #bbb;
  }
  .tab-button.active {
    background-color: #007aff;
    color: white;
    border-color: #007aff;
  }


  #mainContainer {
     display: flex;
     flex-direction: column;
     width: 80%;
     max-width: 1400px;
     height: 70vh;
     max-height: 800px;
     background-color: #444;
     border-radius: 12px;
     box-shadow: 0 8px 25px rgba(0,0,0,0.15);
     overflow: hidden;
     position: relative;
     /* Add margin-bottom to create space for controls if they are too close */
     /* margin-bottom: 20px; */ /* Adjust as needed, or use margin-top on #controls */
   }
  #videoContainer {
    flex: 1;
    position: relative;
    background-color: #000000;
    min-height: 0;
  }
  #canvasContainer {
    flex: 1;
    position: relative; /* For absolute positioning of #controlsGuide */
    background-color: #333333;
    min-height: 0;
  }
  video {
    display: block;
    width: 100%;
    height: 100%;
    object-fit: cover;
    border-top-left-radius: 12px;
    border-top-right-radius: 12px;
  }
  canvas {
    display: block;
    width: 100%;
    height: 100%;
    border-bottom-left-radius: 12px;
    border-bottom-right-radius: 12px;
  }

  @keyframes controlsPulseFade {
    0% { opacity: 0.8; }
    20% { opacity: 0.3; }
    40% { opacity: 0.8; }
    60% { opacity: 0.3; }
    80% { opacity: 0.8; }
    100% { opacity: 0.8; }
  }

  #controls {
    margin-top: 20px;
    display: flex;
    align-items: center;
    gap: 15px;
    background: rgba(40, 40, 40, 0.85);
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    padding: 10px 20px;
    border-radius: 10px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    opacity: 0.8;
  }


  #playPause {
    background-color: #007aff;
    color: white;
    border: none;
    padding: 10px 18px;
    border-radius: 7px;
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    transition: background-color 0.2s ease, transform 0.1s ease;
    min-width: 70px;
    text-align: center;
  }
  #playPause:hover {
    background-color: #005ecb;
  }
  #playPause:active {
    transform: scale(0.96);
  }
  #playPause:disabled {
      opacity: 0.6;
      background-color: #6c757d;
      cursor: not-allowed;
  }

  #progress {
    -webkit-appearance: none;
    appearance: none;
    width: 220px;
    height: 8px;
    background: #555;
    border-radius: 5px;
    outline: none;
    cursor: pointer;
    transition: opacity 0.2s ease;
  }
  #progress:hover {
    opacity: 0.9;
  }

  #progress::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 18px;
    height: 18px;
    background: #007aff;
    border-radius: 50%;
    cursor: pointer;
    margin-top: -5px; /* (thumb height - track height) / 2 * -1 */
    box-shadow: 0 0 5px rgba(0, 122, 255, 0.5);
    transition: transform 0.1s ease;
  }
  #progress::-webkit-slider-thumb:active {
      transform: scale(1.2);
  }

  #progress::-moz-range-thumb {
    width: 18px;
    height: 18px;
    background: #007aff;
    border-radius: 50%;
    cursor: pointer;
    border: none;
    box-shadow: 0 0 5px rgba(0, 122, 255, 0.5);
  }
   #progress::-moz-range-thumb:active {
      transform: scale(1.2);
  }

  #controlsGuide {
    position: absolute;
    top: 10px;
    left: 10px;
    padding: 8px 12px;
    background-color: rgba(0, 0, 0, 0.65);
    color: white;
    border-radius: 5px;
    font-size: 12px;
    line-height: 1.5;
    z-index: 100;
    font-family: Arial, sans-serif;
    pointer-events: none;
    animation: controlsPulseFade 1s 5;
  }
</style>
<body>
  <h1 id="mainTitle">3D Reconstruction Demo</h1>

  <div id="tabsContainer">
    <!-- Tabs will be generated by JS -->
  </div>

  <div id="mainContainer">
    <div id="videoContainer">
      <video id="overlayVideo"
             loop
             muted
             playsinline
             preload="auto">
        Your browser does not support HTML5 video.
      </video>
    </div>

    <div id="canvasContainer">
      <!-- Canvas and controls guide will be appended here -->
    </div>
  </div>

  <div id="controls">
    <button id="playPause">Play</button>
    <input type="range" id="progress" min="0" max="1" step="0.001" value="0">
  </div>

  <script type="module">
    import * as THREE from 'https://esm.sh/three@0.161.0';
    import { OrbitControls } from 'https://esm.sh/three@0.161.0/examples/jsm/controls/OrbitControls.js';
    import { GLTFLoader } from 'https://esm.sh/three@0.161.0/examples/jsm/loaders/GLTFLoader.js';

    let scene, camera, renderer, orbitControls;
    let plainMat = null; // Default material for GLTF models if no color override
    const cars = new Map(); // Stores { mesh: THREE.Object3D, type: String, currentColorStr: "r,g,b" }

    const modelConfigs = [
        { name: 'Car',   file: 'car.glb',   scale: 0.1,  rotationYOffset: -0.2,        verticalOffset: -2  },
        { name: 'Van',   file: 'van.glb',   scale: 4,    rotationYOffset: -Math.PI / 2,  verticalOffset: -2  },
        { name: 'Truck', file: 'van.glb', scale: 3,    rotationYOffset: 0,           verticalOffset: -2  },
        { name: 'Tram',  file: 'tram.glb',  scale: 1.5,    rotationYOffset: -0.1,        verticalOffset: -2  },
    ];
    const modelAssets = new Map();

    let simTimeAbs = 0;
    let playing = false;
    let frameIdx = 0;
    let simDuration = 1;
    let simMap = new Map();
    let timesArr = [];

    const overlayVideo = document.getElementById('overlayVideo');
    const canvasContainer = document.getElementById('canvasContainer');
    const playBtn = document.getElementById('playPause');
    const slider = document.getElementById('progress');
    const tabsContainer = document.getElementById('tabsContainer');

    const datasets = [
      { video: "output_videos/0000.mp4", json: "json_files/0000.json", name: "Scene 1" },
      { video: "output_videos/0001.mp4", json: "json_files/0001.json", name: "Scene 2" },
      { video: "output_videos/0002.mp4", json: "json_files/0002.json", name: "Scene 3" },
      { video: "output_videos/0003.mp4", json: "json_files/0003.json", name: "Scene 4" },
      { video: "output_videos/0004.mp4", json: "json_files/0004.json", name: "Scene 5" },
    ];
    let currentDatasetIndex = 0;
    let videoReadyPromise = null;

    async function setupThreeJSBase() {
      console.log('setupThreeJSBase() CALLED');
      try {
        const loader = new GLTFLoader();
        // This material will be used if a GLTF model part doesn't have its own,
        // or as a fallback if JSON doesn't provide a color for dynamic cars.
        plainMat = new THREE.MeshStandardMaterial({
            color: 0xdddddd, // Default color for models without texture or override
            metalness: 0.4,
            roughness: 0.6,
            // transparent: true, // Enable if models might have transparency not handled by GLTF
            // opacity: 0.9,    // Example opacity
        });


        console.log("Loading 3D models...");
        for (const config of modelConfigs) {
            try {
                const gltf = await loader.loadAsync(config.file);
                const proto = gltf.scene;
                proto.scale.set(config.scale, config.scale, config.scale);

                // Apply plainMat as a default to parts that might not have materials defined
                // This ensures they are visible and can be colored later if needed.
                // However, GLTFLoader usually assigns materials if they are in the GLB.
                // This step is more of a fallback or if you want to ensure a uniform base.
                proto.traverse(n => {
                    if (n.isMesh) {
                        if (!n.material) { // If a mesh part has NO material
                           n.material = plainMat;
                        } else if (Array.isArray(n.material)) { // If it's a MultiMaterial
                            n.material.forEach((mat, idx) => {
                                if (!mat) n.material[idx] = plainMat;
                            });
                        }
                        // We will handle specific color overrides from JSON later for dynamic cars
                    }
                });

                const bbox = new THREE.Box3().setFromObject(proto);
                const calculatedBaseOffsetY = bbox.min.y === Infinity || bbox.min.y === -Infinity ? 0 : -bbox.min.y;

                modelAssets.set(config.name, {
                    proto: proto,
                    baseOffsetY: calculatedBaseOffsetY,
                    rotationYOffset: config.rotationYOffset,
                    verticalOffset: config.verticalOffset
                });
                console.log(`Model "${config.name}" (${config.file}) loaded. Scale: ${config.scale}, BaseOffsetY: ${calculatedBaseOffsetY.toFixed(3)}, RotOffset: ${config.rotationYOffset.toFixed(3)}, VertOffset: ${config.verticalOffset.toFixed(3)}`);
            } catch (err) {
                console.error(`Failed to load model ${config.file} for type ${config.name}:`, err);
            }
        }
        if (modelAssets.size === 0) {
             throw new Error("No 3D models could be loaded. Application cannot start.");
        }
        console.log("All available models processed.");

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xeeeeee);
        camera = new THREE.PerspectiveCamera(60, canvasContainer.clientWidth / canvasContainer.clientHeight, 0.1, 1000);
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
        renderer.shadowMap.enabled = true;
        canvasContainer.appendChild(renderer.domElement);

        const controlsGuide = document.createElement('div');
        controlsGuide.id = 'controlsGuide';
        controlsGuide.innerHTML = '<strong>Controls:</strong><br>Left Click: Rotate View<br>Right Click: Pan View<br>Scroll Wheel: Zoom';
        canvasContainer.appendChild(controlsGuide);

        scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 1.5));
        const dir = new THREE.DirectionalLight(0xffffff, 1.2);
        dir.position.set(-30, 50, 30);
        dir.castShadow = true;
        dir.shadow.mapSize.width = 1024; dir.shadow.mapSize.height = 1024;
        scene.add(dir);
        scene.add(new THREE.AmbientLight(0x404040, 0.5));

        orbitControls = new OrbitControls(camera, renderer.domElement);
        orbitControls.enableDamping = true;

        // Static car for initial camera setup reference - uses its original texture
        if (modelAssets.has('Car')) {
            const carAsset = modelAssets.get('Car');
            const staticCarMesh = carAsset.proto.clone(true); // Clone includes materials from GLTF
            staticCarMesh.position.set(0, carAsset.baseOffsetY , 0);
            staticCarMesh.rotation.y = 1.35;
            staticCarMesh.traverse(n => {
                if (n.isMesh) {
                    // It will use materials from the GLB. If a part has no material,
                    // the traverse in model loading above *might* have set plainMat.
                    // If you want to ensure it uses plainMat as a base if no texture:
                    // if (!n.material || (Array.isArray(n.material) && !n.material.length)) {
                    //    n.material = plainMat;
                    // }
                    n.castShadow = true;
                    n.receiveShadow = true;
                }
            });
            scene.add(staticCarMesh);
            staticCarMesh.updateMatrixWorld(true);
        }

        // Add back the green test cube
        const testCubeGeo = new THREE.BoxGeometry(5, 5, 5);
        const testCubeMat = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true });
        const testCube = new THREE.Mesh(testCubeGeo, testCubeMat);
        testCube.position.set(0, 2.5, 0); // Position it so its bottom is at y=0
        scene.add(testCube);


        camera.position.set(0.16, 10.71, -11.03);
        orbitControls.target.set(0.13, 3.15, 1.49);
        orbitControls.update();

        const gridSize=200, divisions=100, half=gridSize/2, step=gridSize/divisions; const geoLines=new THREE.BufferGeometry();
        const positions=[], colorsWithAlpha=[]; const color1=new THREE.Color(0x000000),color2=new THREE.Color(0x808080);
        const maxLineOpacity=0.75, fadeOutRadius=half, fadePower=1.5;
        function getAlphaForVertex(x,z){const d=Math.sqrt(x*x+z*z),nD=Math.min(1.0,d/fadeOutRadius);return Math.max(0.0,maxLineOpacity*Math.pow(1.0-nD,fadePower));}
        for(let i=0;i<=divisions;i++){const lC=-half+i*step,iE=i%2===0,bC=iE?color1:color2;for(let j=0;j<divisions;j++){const z1=-half+j*step,z2=-half+(j+1)*step;positions.push(lC,0,z1,lC,0,z2);const a1=getAlphaForVertex(lC,z1),a2=getAlphaForVertex(lC,z2);colorsWithAlpha.push(bC.r,bC.g,bC.b,a1,bC.r,bC.g,bC.b,a2);}for(let j=0;j<divisions;j++){const x1=-half+j*step,x2=-half+(j+1)*step;positions.push(x1,0,lC,x2,0,lC);const a1=getAlphaForVertex(x1,lC),a2=getAlphaForVertex(x2,lC);colorsWithAlpha.push(bC.r,bC.g,bC.b,a1,bC.r,bC.g,bC.b,a2);}}
        geoLines.setAttribute('position',new THREE.Float32BufferAttribute(positions,3)); geoLines.setAttribute('color',new THREE.Float32BufferAttribute(colorsWithAlpha,4));
        const matLines=new THREE.LineBasicMaterial({vertexColors:true,transparent:true,linewidth:1}); const grid=new THREE.LineSegments(geoLines,matLines); scene.add(grid);

        window.addEventListener('resize', () => {
          const newCanvasWidth = canvasContainer.clientWidth;
          const newCanvasHeight = canvasContainer.clientHeight;
          if (newCanvasWidth > 0 && newCanvasHeight > 0) {
            camera.aspect = newCanvasWidth / newCanvasHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(newCanvasWidth, newCanvasHeight);
          }
        });
        window.dispatchEvent(new Event('resize'));

        animate();
        return true;

      } catch (error) {
        console.error("Error in setupThreeJSBase:", error);
        canvasContainer.innerHTML = `<p style="color: red; padding: 20px;">Error setting up 3D scene: ${error.message}. Check console.</p>`;
        return false;
      }
    }

    async function loadDataset(index) {
      console.log(`loadDataset(${index}) CALLED`);
      if (index < 0 || index >= datasets.length) {
        console.error("Invalid dataset index:", index);
        return;
      }
      currentDatasetIndex = index;
      const dataset = datasets[index];

      playBtn.disabled = true;
      playBtn.textContent = 'Loading...';
      if (!overlayVideo.paused) {
        overlayVideo.pause();
      }
      playing = false;

      for (const carEntry of cars.values()) {
        if (scene && carEntry.mesh) {
            // Dispose materials if they are unique per car (not the original GLTF materials)
            carEntry.mesh.traverse(child => {
                if (child.isMesh && child.material) {
                    // Check if material was dynamically created (not part of original GLTF)
                    // This is a bit tricky. A simpler approach for now: if it's not plainMat, dispose.
                    // A more robust way would be to tag dynamically created materials.
                    if (child.material !== plainMat && !child.material.isGLTFMaterial) { // A heuristic
                         child.material.dispose();
                    }
                }
            });
            scene.remove(carEntry.mesh);
        }
      }
      cars.clear();

      simTimeAbs = 0;
      frameIdx = 0;
      simMap.clear();
      timesArr = [];
      simDuration = 1;
      slider.value = 0;

      videoReadyPromise = new Promise((resolve, reject) => {
        const onLoadedMetadata = () => {
          overlayVideo.removeEventListener('loadedmetadata', onLoadedMetadata);
          overlayVideo.removeEventListener('error', onErrorDuringLoad);
          if (isFinite(overlayVideo.duration) && overlayVideo.duration > 0) {
            simDuration = overlayVideo.duration;
            console.log(`Video metadata loaded. Video Duration: ${simDuration.toFixed(3)}s. This will be simDuration.`);
            resolve();
          } else {
            console.error("Video duration is invalid after loadedmetadata.");
            reject(new Error("Invalid video duration."));
          }
        };
        const onErrorDuringLoad = (e) => {
            overlayVideo.removeEventListener('loadedmetadata', onLoadedMetadata);
            overlayVideo.removeEventListener('error', onErrorDuringLoad);
            console.error("Error loading video for metadata:", e);
            reject(new Error("Video load error for metadata."));
        };
        overlayVideo.addEventListener('loadedmetadata', onLoadedMetadata);
        overlayVideo.addEventListener('error', onErrorDuringLoad);
      });

      console.log(`Loading video: ${dataset.video}`);
      overlayVideo.src = dataset.video;
      overlayVideo.load();

      try {
        console.log(`Fetching JSON: ${dataset.json}`);
        const response = await fetch(dataset.json);
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status} for ${dataset.json}`);
        }
        const simData = await response.json();
        const originalFrameKeys = Object.keys(simData).sort((a,b)=>parseFloat(a)-parseFloat(b));
        const originalTimesArr  = originalFrameKeys.map(k=>parseFloat(k));

        console.log(`JSON data loaded. Original time entries: ${originalTimesArr.length}`);
        if (originalTimesArr.length === 0) {
            console.warn("JSON contains no time entries. Simulation will be empty.");
            await videoReadyPromise.catch(e => console.warn("Video readiness error, but proceeding with empty sim: ", e));
            playBtn.textContent = 'Play';
            playBtn.disabled = originalTimesArr.length === 0 || !!overlayVideo.error;
            return;
        }

        await videoReadyPromise;

        const originalJsonStartTime = originalTimesArr[0];
        const originalJsonEndTime = originalTimesArr[originalTimesArr.length - 1];
        const originalJsonDuration = originalJsonEndTime - originalJsonStartTime;

        simMap.clear();
        timesArr = [];

        if (originalJsonDuration > 0) {
            const scaleFactor = simDuration / originalJsonDuration;
            originalTimesArr.forEach(t => {
                const originalData = simData[t.toString()];
                const scaledTime = (t - originalJsonStartTime) * scaleFactor;
                simMap.set(scaledTime, originalData);
            });
            timesArr = Array.from(simMap.keys()).sort((a,b) => a - b);
        } else {
            originalTimesArr.forEach(t => {
                 const originalData = simData[t.toString()];
                 simMap.set(0, originalData);
            });
             timesArr = [0];
             if (simDuration > 0 && originalTimesArr.length > 1) {
                console.warn("Multiple JSON frames at the same original time, only using first for time 0.");
             }
        }

        console.log(`Simulation data re-scaled. New time entries: ${timesArr.length}. Duration matches video: ${simDuration.toFixed(3)}s`);
        if (timesArr.length > 0) {
          console.log(`First scaled time: ${timesArr[0].toFixed(3)}, Last scaled time: ${timesArr[timesArr.length-1].toFixed(3)}`);
        }

      } catch (error) {
        console.error(`Error processing dataset for ${dataset.name}:`, error);
        playBtn.textContent = 'Error';
      } finally {
        if (!overlayVideo.error && playBtn.disabled) {
            playBtn.textContent = overlayVideo.paused ? 'Play' : 'Pause';
            playBtn.disabled = false;
        }
      }

      document.querySelectorAll('#tabsContainer .tab-button').forEach((btn, i) => {
        btn.classList.toggle('active', i === currentDatasetIndex);
      });
    }

    function setupEventListeners() {
      overlayVideo.addEventListener('canplay', () => {
        console.log('Video: canplay. Video error:', overlayVideo.error);
        if (overlayVideo.error) return;
        playBtn.textContent = overlayVideo.paused ? 'Play' : 'Pause';
        playBtn.disabled = false;
      });
      overlayVideo.addEventListener('canplaythrough', () => console.log('Video: canplaythrough'));

      overlayVideo.addEventListener('playing', () => {
          if (overlayVideo.error) return;
          playing = true;
          playBtn.textContent = 'Pause';
          playBtn.disabled = false;
          console.log(`Video "playing" event. playing=${playing}, video.currentTime=${overlayVideo.currentTime.toFixed(3)}`);
      });

      overlayVideo.addEventListener('pause', () => {
          if (overlayVideo.error) return;
          playing = false;
          playBtn.textContent = 'Play';
          playBtn.disabled = false;
          console.log(`Video "pause" event. playing=${playing}, video.currentTime=${overlayVideo.currentTime.toFixed(3)}`);
      });

      overlayVideo.addEventListener('ended', () => {
        if (overlayVideo.error) return;
        console.log('Video: "ended" EVENT FIRED');
        playing = false;
        playBtn.textContent = 'Play';
      });

      overlayVideo.addEventListener('seeked', () => {
          if (overlayVideo.error) return;
          console.log(`Video: "seeked" EVENT. currentTime: ${overlayVideo.currentTime.toFixed(3)}`);
          simTimeAbs = overlayVideo.currentTime;
          frameIdx = 0;

          if (overlayVideo.paused) {
              playing = false;
              playBtn.textContent = 'Play';
              playBtn.disabled = false;
          }
          if (!slider.matches(':active')) {
              slider.value = simDuration > 0 ? simTimeAbs / simDuration : 0;
          }
          console.log(`Seeked: simTimeAbs=${simTimeAbs.toFixed(3)}, slider.value=${slider.value}`);
          updateSceneObjects(simTimeAbs);
      });

      overlayVideo.addEventListener('error', e => {
        console.error('Video: ERROR event!', e);
        let errorMsg = 'Video Error';
        if (overlayVideo.error) {
            console.error('Video error details - Code:', overlayVideo.error.code, 'Message:', overlayVideo.error.message);
             switch (overlayVideo.error.code) {
                case MediaError.MEDIA_ERR_ABORTED: errorMsg = 'Vid Load Aborted'; break;
                case MediaError.MEDIA_ERR_NETWORK: errorMsg = 'Vid Network Err'; break;
                case MediaError.MEDIA_ERR_DECODE: errorMsg = 'Vid Decode Err'; break;
                case MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED: errorMsg = 'Vid Format Err'; break;
                default: errorMsg = 'Vid Unknown Err';
            }
        }
        playBtn.textContent = errorMsg;
        playBtn.disabled = true;
        playing = false;
      });

      playBtn.addEventListener('click', () => {
        if (playBtn.disabled || overlayVideo.error) return;
        playBtn.disabled = true;

        if (overlayVideo.paused) {
          console.log("Play button: Attempting to play video...");
          overlayVideo.play().catch(e => {
            console.error("video.play() promise rejected:", e);
            playBtn.disabled = false;
            playBtn.textContent = 'Play';
            playing = false;
          });
        } else {
          console.log("Play button: Attempting to pause video...");
          overlayVideo.pause();
        }
      });

      slider.addEventListener('input', () => {
        if (overlayVideo.error || !isFinite(simDuration) || simDuration <= 0) return;

        const targetVideoTime = parseFloat(slider.value) * simDuration;

        if (Math.abs(targetVideoTime - overlayVideo.currentTime) > 0.05) {
            if (!overlayVideo.paused) {
                overlayVideo.pause();
            } else {
                playing = false;
                playBtn.textContent = 'Play';
                playBtn.disabled = false;
            }
            overlayVideo.currentTime = Math.max(0, Math.min(targetVideoTime, simDuration - 0.01));
        }
      });
    }

    function generateTabs() {
        tabsContainer.innerHTML = '';
        datasets.forEach((dataset, index) => {
            const button = document.createElement('button');
            button.classList.add('tab-button');
            button.textContent = dataset.name;
            button.dataset.index = index;
            if (index === currentDatasetIndex) {
                button.classList.add('active');
            }
            button.addEventListener('click', () => {
                if (index !== currentDatasetIndex && !playBtn.disabled) {
                    loadDataset(index);
                }
            });
            tabsContainer.appendChild(button);
        });
    }

    function updateSceneObjects(currentSimTime) {
        if (timesArr.length > 0) {
            if (frameIdx > 0 && currentSimTime < timesArr[frameIdx]) {
              frameIdx = 0;
            }
            while (frameIdx < timesArr.length - 1 && currentSimTime >= timesArr[frameIdx + 1]) {
              frameIdx++;
            }
        } else {
            frameIdx = 0;
        }

        const frameData = (timesArr.length > 0 && simMap.has(timesArr[frameIdx])) ? simMap.get(timesArr[frameIdx]) : [];
        const presentIds = new Set();
        if (Array.isArray(frameData)) {
            frameData.forEach((o,i) => presentIds.add(o.id !== undefined ? String(o.id) : String(i)));
        }

        for (let id of cars.keys()) {
            if (!presentIds.has(id)) {
                const carEntry = cars.get(id);
                if (carEntry && carEntry.mesh) {
                    carEntry.mesh.traverse(child => { // Dispose dynamically created materials
                        if (child.isMesh && child.material && child.material.userData.isDynamicColor) {
                            child.material.dispose();
                        }
                    });
                    scene.remove(carEntry.mesh);
                }
                cars.delete(id);
            }
        }

        if (Array.isArray(frameData) && modelAssets.size > 0) {
            frameData.forEach((o,i) => {
                const id = o.id !== undefined ? String(o.id) : String(i);
                const type = o.type || 'Car';
                const asset = modelAssets.get(type);

                if (!asset) {
                    if (cars.has(id)) { scene.remove(cars.get(id).mesh); cars.delete(id); }
                    return;
                }
                if (![o.x, o.y, o.z, o.rotation_y].every(val => typeof val === 'number' && isFinite(val))) {
                    console.warn(`Invalid position/rotation data for object ID: ${id}, type: ${type}`, o);
                    if (cars.has(id)) { scene.remove(cars.get(id).mesh); cars.delete(id); }
                    return;
                }

                const yPos = o.y + asset.baseOffsetY + asset.verticalOffset;
                const xPos = -o.x;
                const zPos = o.z;
                const yaw = o.rotation_y;
                let carEntry = cars.get(id);

                const objectColorRGB = o.color;
                let newColorStr = "gltf_default"; // Default to using GLTF materials

                if (Array.isArray(objectColorRGB) && objectColorRGB.length === 3) {
                    newColorStr = `rgb(${objectColorRGB.join(',')})`;
                }


                if (carEntry && carEntry.type !== type) {
                     carEntry.mesh.traverse(child => { // Dispose dynamically created materials
                        if (child.isMesh && child.material && child.material.userData.isDynamicColor) {
                            child.material.dispose();
                        }
                    });
                    scene.remove(carEntry.mesh);
                    cars.delete(id);
                    carEntry = null;
                }

                if (!carEntry) {
                    const newMesh = asset.proto.clone(true); // Clones GLTF materials by default

                    if (Array.isArray(objectColorRGB) && objectColorRGB.length === 3) {
                        // Override with new color material
                        const newMaterial = new THREE.MeshStandardMaterial({
                            color: new THREE.Color(objectColorRGB[0]/255, objectColorRGB[1]/255, objectColorRGB[2]/255),
                            metalness: 0.4, // Or from JSON if available
                            roughness: 0.6 // Or from JSON if available
                        });
                        newMaterial.userData.isDynamicColor = true; // Mark it
                        newMesh.traverse(n => {
                            if (n.isMesh) n.material = newMaterial;
                        });
                    }
                    // Else, it uses the materials cloned from asset.proto (original GLTF materials)

                    newMesh.traverse(n => { // Ensure shadow casting for all parts
                        if (n.isMesh) {
                            n.castShadow = true;
                            n.receiveShadow = true;
                        }
                    });

                    scene.add(newMesh);
                    carEntry = { mesh: newMesh, type: type, currentColorStr: newColorStr };
                    cars.set(id, carEntry);
                } else {
                    // Update color only if it has changed
                    if (carEntry.currentColorStr !== newColorStr) {
                        // Dispose old dynamic materials
                        carEntry.mesh.traverse(child => {
                           if (child.isMesh && child.material && child.material.userData.isDynamicColor) {
                               child.material.dispose();
                           }
                        });

                        if (Array.isArray(objectColorRGB) && objectColorRGB.length === 3) {
                            const updatedMaterial = new THREE.MeshStandardMaterial({
                                color: new THREE.Color(objectColorRGB[0]/255, objectColorRGB[1]/255, objectColorRGB[2]/255),
                                metalness: 0.4,
                                roughness: 0.6
                            });
                            updatedMaterial.userData.isDynamicColor = true;
                            carEntry.mesh.traverse(n => {
                               if (n.isMesh) n.material = updatedMaterial;
                            });
                        } else { // Revert to original GLTF materials
                            const originalProtoMesh = asset.proto.clone(true);
                            carEntry.mesh.traverse(n => {
                               if (n.isMesh) {
                                   const correspondingProtoNode = originalProtoMesh.getObjectByName(n.name);
                                   if (correspondingProtoNode && correspondingProtoNode.isMesh) {
                                       n.material = correspondingProtoNode.material;
                                   } else {
                                       n.material = plainMat; // Fallback
                                   }
                               }
                            });
                        }
                        carEntry.currentColorStr = newColorStr;
                    }
                }

                carEntry.mesh.position.set(xPos, yPos, zPos);
                carEntry.mesh.rotation.set(0, (2 * Math.PI - yaw) + asset.rotationYOffset, 0);
            });
        }
    }

    function animate() {
      requestAnimationFrame(animate);

      if (playing) {
        simTimeAbs = overlayVideo.currentTime;
      }

      if (isFinite(simDuration) && simDuration > 0 && !slider.matches(':active')) {
          slider.value = simTimeAbs / simDuration;
      } else if ((!isFinite(simDuration) || simDuration <= 0) && !slider.matches(':active')) {
          slider.value = 0;
      }

      updateSceneObjects(simTimeAbs);

      if (orbitControls) orbitControls.update();
      if (renderer && scene && camera) renderer.render(scene, camera);
    }

    async function main() {
      console.log('main() CALLED');
      playBtn.disabled = true;
      playBtn.textContent = 'Loading...';

      const threeJsReady = await setupThreeJSBase();
      if (!threeJsReady) {
          playBtn.textContent = '3D Error';
          return;
      }

      generateTabs();
      setupEventListeners();
      await loadDataset(currentDatasetIndex);
    }

    main().catch(err => {
        console.error("CRITICAL FAILURE in main() promise:", err);
        if (canvasContainer) {
            canvasContainer.innerHTML = `<p style="color: red; padding: 20px;">Critical script error: ${err.message}. Check console.</p>`;
        }
        if (playBtn) {
            playBtn.textContent = 'Fatal Error';
            playBtn.disabled = true;
        }
    });
  </script>
</body>
</html>
