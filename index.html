<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>Car Animation with Video Controls - Split Screen</title>
  <style>
    /* ADDED: Global box-sizing for easier layout management */
    *, *::before, *::after {
      box-sizing: border-box;
    }

    html, body { /* Ensure html and body take full height */
      height: 100%;
      margin: 0;
      padding: 0;
    }

    body {
      display: flex;
      align-items: center;
      justify-content: center;
      background-color: #fff; /* CHANGED: Page background to white */
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    }

    #pageWrapper {
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 100%;
      max-width: 1600px;
      padding: 20px; /* CHANGED: Consistent padding */
      overflow-y: auto;
      max-height: 100%;
    }

    #mainTitle {
      font-size: 28px;
      font-weight: 600;
      color: #333;
      text-align: center;
      margin-bottom: 25px;
      letter-spacing: 0.5px;
      padding: 5px 0;
      flex-shrink: 0;
    }

    #tabsContainer {
      margin-bottom: 15px;
      display: flex;
      gap: 8px; /* Slightly reduced gap */
      flex-shrink: 0;
      flex-wrap: wrap; /* ADDED: Allow tabs to wrap */
      justify-content: center; /* ADDED: Center tabs when they wrap */
      padding: 0 10px; /* ADDED: Side padding for tabs container */
      width: 100%; /* Ensure it can use the padding effectively */
      max-width: 700px; /* Optional: constrain max width of tabs area */
    }

    .tab-button {
      padding: 7px 12px; /* UPDATED: Slightly smaller padding */
      font-size: 13px; /* UPDATED: Slightly smaller font */
      font-weight: 500;
      border: 1px solid #ccc;
      background-color: #fff;
      color: #333;
      border-radius: 6px;
      cursor: pointer;
      transition: background-color 0.2s ease, color 0.2s ease, border-color 0.2s ease;
      flex-grow: 1; /* Allow buttons to grow if space available */
      text-align: center;
      min-width: 80px; /* Ensure buttons don't get too squished */
    }
    .tab-button:hover {
      background-color: #e9e9e9;
      border-color: #bbb;
    }
    .tab-button.active {
      background-color: #007aff;
      color: white;
      border-color: #007aff;
    }

    #mainContainer {
        display: flex;
        flex-direction: column;
        width: 90%; /* CHANGED: Slightly more responsive width */
        max-width: 1400px;
        background-color: #444;
        border-radius: 12px;
        box-shadow: 0 8px 25px rgba(0,0,0,0.15);
        overflow: hidden;
        position: relative;
        aspect-ratio: 96 / 58;
    }

    #videoContainer, #canvasContainer {
        width: 100%;
        position: relative;
        aspect-ratio: 96 / 29;
        background-color: #000;
        overflow: hidden;
        min-width: 0;
        min-height: 0;
    }
    #videoContainer {
        background-color: #000;
    }
    #canvasContainer {
        background-color: #333;
    }

    video, canvas {
        display: block;
        width: 100%;
        height: 100%;
        object-fit: cover;
    }

    #videoContainer {
        border-top-left-radius: 12px;
        border-top-right-radius: 12px;
    }
    #canvasContainer {
        border-bottom-left-radius: 12px;
        border-bottom-right-radius: 12px;
    }
    video {
        border-top-left-radius: 0;
        border-top-right-radius: 0;
    }
    canvas {
        border-bottom-left-radius: 0;
        border-bottom-right-radius: 0;
    }

    @keyframes controlsPulseFade {
      0% { opacity: 0.8; }
      20% { opacity: 0.3; }
      40% { opacity: 0.8; }
      60% { opacity: 0.3; }
      80% { opacity: 0.8; }
      100% { opacity: 0.8; }
    }

    #controls {
      margin-top: 20px;
      display: flex;
      align-items: center;
      gap: 15px;
      background: rgba(40, 40, 40, 0.85);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      padding: 10px 20px;
      border-radius: 10px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      opacity: 0.8;
      flex-shrink: 0;
      flex-wrap: wrap; /* Allow controls to wrap if needed on very small screens */
      justify-content: center; /* Center controls if they wrap */
    }

    #playPause {
      background-color: #007aff;
      color: white;
      border: none;
      padding: 10px 18px;
      border-radius: 7px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: background-color 0.2s ease, transform 0.1s ease;
      min-width: 70px;
      text-align: center;
    }
    #playPause:hover {
      background-color: #005ecb;
    }
    #playPause:active {
      transform: scale(0.96);
    }
    #playPause:disabled {
        opacity: 0.6;
        background-color: #6c757d;
        cursor: not-allowed;
    }

    #progress {
      -webkit-appearance: none;
      appearance: none;
      width: 220px; /* This could also be made responsive, e.g., width: 50vw; max-width: 220px; */
      max-width: 100%; /* Ensure it doesn't overflow its container if flex-wrap occurs */
      height: 8px;
      background: #555;
      border-radius: 5px;
      outline: none;
      cursor: pointer;
      transition: opacity 0.2s ease;
    }
    #progress:hover {
      opacity: 0.9;
    }

    #progress::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 18px;
      height: 18px;
      background: #007aff;
      border-radius: 50%;
      cursor: pointer;
      margin-top: -5px;
      box-shadow: 0 0 5px rgba(0, 122, 255, 0.5);
      transition: transform 0.1s ease;
    }
    #progress::-webkit-slider-thumb:active {
        transform: scale(1.2);
    }

    #progress::-moz-range-thumb {
      width: 18px;
      height: 18px;
      background: #007aff;
      border-radius: 50%;
      cursor: pointer;
      border: none;
      box-shadow: 0 0 5px rgba(0, 122, 255, 0.5);
    }
     #progress::-moz-range-thumb:active {
        transform: scale(1.2);
    }

    #controlsGuide {
      position: absolute;
      top: 10px;
      left: 10px;
      padding: 6px 10px; /* UPDATED: Slightly smaller padding */
      background-color: rgba(0, 0, 0, 0.65);
      color: white;
      border-radius: 5px;
      /* UPDATED: Responsive font size with clamp */
      font-size: clamp(9px, 1.8vw, 12px); /* min, preferred (scales with viewport), max */
      line-height: 1.4; /* Adjusted line-height */
      z-index: 100;
      font-family: Arial, sans-serif;
      pointer-events: none;
      animation: controlsPulseFade 1s 5;
      max-width: 90%; /* Prevent it from getting too wide on small screens */
    }

    /* Media Query for further adjustments on smaller screens if needed */
    @media (max-width: 768px) {
        #mainTitle {
            font-size: 24px; /* Slightly smaller title on mobile */
            margin-bottom: 20px;
        }
        #mainContainer {
            width: 95%; /* Use more width on smaller screens */
            aspect-ratio: unset; /* Allow height to be determined by content on smaller screens */
            height: auto; /* if aspect-ratio is unset */

        }
        #videoContainer, #canvasContainer {
             /* On mobile, perhaps stack them if aspect-ratio becomes an issue,
                or let aspect-ratio: 96/29 define their height based on new width */
             /* aspect-ratio: 16/9; /* Or a more common mobile video aspect ratio */
        }

        #controls {
            gap: 10px;
            padding: 8px 12px;
        }
        #progress {
            width: 150px; /* Smaller progress bar on mobile */
        }
    }
    @media (max-width: 480px) {
        #mainTitle {
            font-size: 20px;
        }
        .tab-button {
            padding: 6px 10px;
            font-size: 12px;
            min-width: 70px; /* Further reduce min-width */
        }
         #tabsContainer {
            gap: 5px;
        }
        #controlsGuide {
            font-size: clamp(8px, 2.5vw, 10px); /* Even smaller for very small screens */
            padding: 5px 8px;
        }
    }

  </style>
<body>
  <div id="pageWrapper"> <!-- NEW WRAPPER -->
    <h1 id="mainTitle">3D Reconstruction Demo</h1>

    <div id="tabsContainer">
      <!-- Tabs will be generated by JS -->
    </div>

    <div id="mainContainer">
      <div id="videoContainer">
        <video id="overlayVideo"
               loop
               muted
               playsinline
               preload="auto">
          Your browser does not support HTML5 video.
        </video>
      </div>

      <div id="canvasContainer">
        <!-- Canvas and controls guide will be appended here -->
      </div>
    </div>

    <div id="controls">
      <button id="playPause">Play</button>
      <input type="range" id="progress" min="0" max="1" step="0.001" value="0">
    </div>
  </div>
  <script type="module">
    import * as THREE from 'https://esm.sh/three@0.161.0';
    import { OrbitControls } from 'https://esm.sh/three@0.161.0/examples/jsm/controls/OrbitControls.js';
    import { GLTFLoader } from 'https://esm.sh/three@0.161.0/examples/jsm/loaders/GLTFLoader.js';
    import { DRACOLoader } from 'https://esm.sh/three@0.161.0/examples/jsm/loaders/DRACOLoader.js';

    let scene, camera, renderer, orbitControls;
    let plainMat = null;
    const cars = new Map();

    const modelConfigs = [
        { name: 'Car',   file: 'car_optimized.glb',   scale: 0.1,  rotationYOffset: -0.2,        verticalOffset: -2  },
        { name: 'Van',   file: 'van_optimized.glb',   scale: 4,    rotationYOffset: -Math.PI / 2,  verticalOffset: -2  },
        { name: 'Truck', file: 'truck_optimized.glb', scale: 3,    rotationYOffset: 0,           verticalOffset: -2  },
        { name: 'Tram',  file: 'tram_optimized.glb',  scale: 1.5,  rotationYOffset: -0.1,        verticalOffset: -2  },
    ];
    const modelAssets = new Map();

    let simTimeAbs = 0;
    let playing = false;
    let frameIdx = 0;
    let simDuration = 1;
    let simMap = new Map();
    let timesArr = [];

    const overlayVideo = document.getElementById('overlayVideo');
    const canvasContainer = document.getElementById('canvasContainer');
    const playBtn = document.getElementById('playPause');
    const slider = document.getElementById('progress');
    const tabsContainer = document.getElementById('tabsContainer');

    const datasets = [
      { video: "output_videos/0000.mp4", json: "json_files/0000.json", name: "Scene 1" },
      { video: "output_videos/0001.mp4", json: "json_files/0001.json", name: "Scene 2" },
      { video: "output_videos/0002.mp4", json: "json_files/0002.json", name: "Scene 3" },
      { video: "output_videos/0003.mp4", json: "json_files/0003.json", name: "Scene 4" },
      { video: "output_videos/0004.mp4", json: "json_files/0004.json", name: "Scene 5" },
    ];
    let currentDatasetIndex = 0;
    let videoReadyPromise = null;

    async function setupThreeJSBase() {
      console.log('setupThreeJSBase() CALLED');
      try {
        const dracoLoader = new DRACOLoader();
        dracoLoader.setDecoderPath('libs/draco/gltf/');

        const loader = new GLTFLoader();
        loader.setDRACOLoader(dracoLoader);

        plainMat = new THREE.MeshStandardMaterial({
            color: 0xdddddd,
            metalness: 0.4,
            roughness: 0.6,
        });

        console.log("Loading 3D models for dynamic instances...");
        for (const config of modelConfigs) {
            try {
                const gltf = await loader.loadAsync(config.file);
                const proto = gltf.scene;
                proto.scale.set(config.scale, config.scale, config.scale);
                proto.traverse(n => {
                    if (n.isMesh) {
                        if (!n.material) { n.material = plainMat.clone(); }
                        else if (Array.isArray(n.material)) {
                            n.material.forEach((mat, idx) => { if (!mat) n.material[idx] = plainMat.clone(); });
                        }
                    }
                });
                const bbox = new THREE.Box3().setFromObject(proto);
                const calculatedBaseOffsetY = bbox.min.y === Infinity || bbox.min.y === -Infinity ? 0 : -bbox.min.y;
                modelAssets.set(config.name, { proto, baseOffsetY: calculatedBaseOffsetY, rotationYOffset: config.rotationYOffset, verticalOffset: config.verticalOffset });
                console.log(`Model "${config.name}" (${config.file}) loaded. Scale: ${config.scale}, Offsets: Y=${calculatedBaseOffsetY.toFixed(3)}, RotY=${config.rotationYOffset.toFixed(3)}, Vert=${config.verticalOffset.toFixed(3)}`);
            } catch (err) {
                console.error(`Failed to load dynamic model ${config.file} for type ${config.name}:`, err);
            }
        }
        if (!modelAssets.has('Car') && modelConfigs.some(c => c.name === 'Car')) {
             console.warn("Default 'Car' model (car_optimized.glb) for dynamic instances failed to load.");
        }
        console.log("Dynamic models processed.");

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xeeeeee); // Canvas background
        camera = new THREE.PerspectiveCamera(60, canvasContainer.clientWidth / canvasContainer.clientHeight, 0.1, 1000);
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
        renderer.shadowMap.enabled = true;
        canvasContainer.appendChild(renderer.domElement);

        const controlsGuideEl = document.createElement('div');
        controlsGuideEl.id = 'controlsGuide';
        controlsGuideEl.innerHTML = '<strong>Controls:</strong><br>L-Click: Rotate<br>R-Click: Pan<br>Scroll: Zoom'; // Shorter text
        canvasContainer.appendChild(controlsGuideEl);

        scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 1.5));
        const dir = new THREE.DirectionalLight(0xffffff, 1.2);
        dir.position.set(-30, 50, 30);
        dir.castShadow = true;
        dir.shadow.mapSize.width = 1024; dir.shadow.mapSize.height = 1024;
        scene.add(dir);
        scene.add(new THREE.AmbientLight(0x404040, 0.5));

        orbitControls = new OrbitControls(camera, renderer.domElement);
        orbitControls.enableDamping = true;

        try {
            console.log("Loading static textured car (car_texture_optimized.glb)...");
            const staticCarGltf = await loader.loadAsync('car_texture_optimized.glb');
            const staticCarProto = staticCarGltf.scene;
            const staticCarScale = 0.1, staticCarVerticalOffset = -2, staticCarRotationY = 1.35;
            staticCarProto.scale.set(staticCarScale, staticCarScale, staticCarScale);
            const bboxStatic = new THREE.Box3().setFromObject(staticCarProto);
            const baseOffsetYStatic = bboxStatic.min.y === Infinity || bboxStatic.min.y === -Infinity ? 0 : -bboxStatic.min.y;
            const staticCarMesh = staticCarProto.clone(true);
            staticCarMesh.position.set(0, baseOffsetYStatic + staticCarVerticalOffset, 0); // Corrected: Added staticCarVerticalOffset
            staticCarMesh.rotation.y = staticCarRotationY;
            staticCarMesh.traverse(n => { if (n.isMesh) { n.castShadow = true; n.receiveShadow = true; }});
            scene.add(staticCarMesh);
            staticCarMesh.updateMatrixWorld(true);
            console.log("Static textured car loaded.");
        } catch (err) {
            console.error("Failed to load static textured car:", err);
            if (modelAssets.has('Car')) {
                console.warn("Falling back to dynamic 'Car' model for static placeholder.");
                const carAsset = modelAssets.get('Car');
                const fallbackStaticCarMesh = carAsset.proto.clone(true);
                fallbackStaticCarMesh.position.set(0, carAsset.baseOffsetY + carAsset.verticalOffset, 0);
                fallbackStaticCarMesh.rotation.y = 1.35;
                fallbackStaticCarMesh.traverse(n => { if (n.isMesh) { n.castShadow = true; n.receiveShadow = true; } });
                scene.add(fallbackStaticCarMesh);
                fallbackStaticCarMesh.updateMatrixWorld(true);
            } else {
                 console.error("CRITICAL: No 'Car' model available for static placeholder.");
            }
        }

        const testCubeGeo = new THREE.BoxGeometry(5,5,5); // Removed for cleaner scene
        // const testCubeMat = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true });
        // const testCube = new THREE.Mesh(testCubeGeo, testCubeMat);
        // testCube.position.set(0, 2.5, 0);
        // scene.add(testCube); // Test cube removed

        camera.position.set(0.16, 10.71, -11.03);
        orbitControls.target.set(0.13, 3.15, 1.49);
        orbitControls.update();

        const gridSize=200, divisions=100, half=gridSize/2, step=gridSize/divisions; const geoLines=new THREE.BufferGeometry();
        const positions=[], colorsWithAlpha=[]; const color1=new THREE.Color(0x000000),color2=new THREE.Color(0x808080);
        const maxLineOpacity=0.75, fadeOutRadius=half, fadePower=1.5;
        function getAlphaForVertex(x,z){const d=Math.sqrt(x*x+z*z),nD=Math.min(1.0,d/fadeOutRadius);return Math.max(0.0,maxLineOpacity*Math.pow(1.0-nD,fadePower));}
        for(let i=0;i<=divisions;i++){const lC=-half+i*step,iE=i%2===0,bC=iE?color1:color2;for(let j=0;j<divisions;j++){const z1=-half+j*step,z2=-half+(j+1)*step;positions.push(lC,0,z1,lC,0,z2);const a1=getAlphaForVertex(lC,z1),a2=getAlphaForVertex(lC,z2);colorsWithAlpha.push(bC.r,bC.g,bC.b,a1,bC.r,bC.g,bC.b,a2);}for(let j=0;j<divisions;j++){const x1=-half+j*step,x2=-half+(j+1)*step;positions.push(x1,0,lC,x2,0,lC);const a1=getAlphaForVertex(x1,lC),a2=getAlphaForVertex(x2,lC);colorsWithAlpha.push(bC.r,bC.g,bC.b,a1,bC.r,bC.g,bC.b,a2);}}
        geoLines.setAttribute('position',new THREE.Float32BufferAttribute(positions,3)); geoLines.setAttribute('color',new THREE.Float32BufferAttribute(colorsWithAlpha,4));
        const matLines=new THREE.LineBasicMaterial({vertexColors:true,transparent:true,linewidth:1}); const grid=new THREE.LineSegments(geoLines,matLines); scene.add(grid);

        window.addEventListener('resize', () => {
          const newCanvasWidth = canvasContainer.clientWidth;
          const newCanvasHeight = canvasContainer.clientHeight;
          if (newCanvasWidth > 0 && newCanvasHeight > 0) {
            camera.aspect = newCanvasWidth / newCanvasHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(newCanvasWidth, newCanvasHeight);
          }
        });
        window.dispatchEvent(new Event('resize'));

        animate();
        return true;

      } catch (error) {
        console.error("Error in setupThreeJSBase:", error);
        canvasContainer.innerHTML = `<p style="color: red; padding: 20px;">Error setting up 3D scene: ${error.message}. Check console.</p>`;
        return false;
      }
    }

    async function loadDataset(index) {
      console.log(`loadDataset(${index}) CALLED`);
      if (index < 0 || index >= datasets.length) {
        console.error("Invalid dataset index:", index);
        return;
      }
      currentDatasetIndex = index;
      const dataset = datasets[index];

      playBtn.disabled = true;
      playBtn.textContent = 'Loading...';
      if (!overlayVideo.paused) {
        overlayVideo.pause();
      }
      playing = false;

      while (overlayVideo.firstChild) {
        overlayVideo.removeChild(overlayVideo.firstChild);
      }
      overlayVideo.removeAttribute('src');

      for (const carEntry of cars.values()) {
        if (scene && carEntry.mesh) {
            carEntry.mesh.traverse(child => {
                if (child.isMesh && child.material && child.material.userData.isDynamicColor) {
                     child.material.dispose();
                }
            });
            scene.remove(carEntry.mesh);
        }
      }
      cars.clear();

      simTimeAbs = 0; frameIdx = 0; simMap.clear(); timesArr = []; simDuration = 1; slider.value = 0;

      let videoBasePath = dataset.video;
      if (videoBasePath.endsWith('.mp4')) {
        videoBasePath = videoBasePath.substring(0, videoBasePath.length - 4);
      }

      const sourceDesktop = document.createElement('source');
      sourceDesktop.src = `${videoBasePath}_desktop.mp4`;
      sourceDesktop.type = 'video/mp4';
      sourceDesktop.media = 'all and (min-width: 769px)';
      overlayVideo.appendChild(sourceDesktop);

      const sourceMobile = document.createElement('source');
      sourceMobile.src = `${videoBasePath}_iphone.mp4`;
      sourceMobile.type = 'video/mp4';
      overlayVideo.appendChild(sourceMobile);

      const fallbackTextNode = document.createTextNode('Your browser does not support HTML5 video or the provided video formats.');
      overlayVideo.appendChild(fallbackTextNode);


      videoReadyPromise = new Promise((resolve, reject) => {
        const onLoadedMetadata = () => {
          if (isFinite(overlayVideo.duration) && overlayVideo.duration > 0) {
            simDuration = overlayVideo.duration;
            const currentSourceURL = overlayVideo.currentSrc;
            let loadedVersion = "unknown";
            if (currentSourceURL.includes("_desktop.mp4")) loadedVersion = "Desktop";
            else if (currentSourceURL.includes("_iphone.mp4")) loadedVersion = "iPhone";
            console.log(`Video metadata loaded. Chosen: ${loadedVersion}. Src: ${currentSourceURL}. Duration: ${simDuration.toFixed(3)}s.`);
            resolve();
          } else {
            console.error(`Invalid video duration. Src: ${overlayVideo.currentSrc}`);
            reject(new Error("Invalid video duration."));
          }
        };
        const onErrorDuringLoad = (e) => {
            console.error("Video load error:", e, `Src: ${overlayVideo.currentSrc}`, "Sources:", Array.from(overlayVideo.querySelectorAll('source')).map(s => s.src));
            reject(new Error("Video load error for metadata."));
        };
        overlayVideo.addEventListener('loadedmetadata', onLoadedMetadata, { once: true });
        overlayVideo.addEventListener('error', onErrorDuringLoad, { once: true });
      });

      console.log(`Loading video. Desktop: ${sourceDesktop.src}, Mobile: ${sourceMobile.src}`);
      overlayVideo.load();

      try {
        console.log(`Fetching JSON: ${dataset.json}`);
        const response = await fetch(dataset.json);
        if (!response.ok) throw new Error(`HTTP ${response.status} for ${dataset.json}`);
        const simData = await response.json();
        const originalFrameKeys = Object.keys(simData).sort((a,b)=>parseFloat(a)-parseFloat(b));
        const originalTimesArr  = originalFrameKeys.map(k=>parseFloat(k));

        console.log(`JSON loaded. Entries: ${originalTimesArr.length}`);
        if (originalTimesArr.length === 0) {
            console.warn("JSON empty.");
            await videoReadyPromise.catch(e => console.warn("Video error (empty JSON): ", e));
            playBtn.textContent = 'Play';
            playBtn.disabled = !!overlayVideo.error;
            return;
        }

        await videoReadyPromise;

        const originalJsonStartTime = originalTimesArr[0];
        const originalJsonEndTime = originalTimesArr[originalTimesArr.length - 1];
        const originalJsonDuration = originalJsonEndTime - originalJsonStartTime;

        simMap.clear(); timesArr = [];
        if (originalJsonDuration > 0) {
            const scaleFactor = simDuration / originalJsonDuration;
            originalTimesArr.forEach(t => simMap.set((t - originalJsonStartTime) * scaleFactor, simData[t.toString()]));
            timesArr = Array.from(simMap.keys()).sort((a,b) => a - b);
        } else {
            originalTimesArr.forEach(t => simMap.set(0, simData[t.toString()]));
            timesArr = [0];
            if (simDuration > 0 && originalTimesArr.length > 1) console.warn("Multiple JSON frames at t=0.");
        }
        console.log(`Sim data re-scaled. Entries: ${timesArr.length}. Duration: ${simDuration.toFixed(3)}s. Range: ${timesArr.length > 0 ? timesArr[0].toFixed(3) : 'N/A'} - ${timesArr.length > 0 ? timesArr[timesArr.length-1].toFixed(3) : 'N/A'}`);

      } catch (error) {
        console.error(`Error processing dataset ${dataset.name}:`, error);
        playBtn.textContent = 'Error';
      } finally {
        if (!overlayVideo.error && playBtn.disabled) {
            playBtn.textContent = overlayVideo.paused ? 'Play' : 'Pause';
            playBtn.disabled = false;
        }
      }
      document.querySelectorAll('#tabsContainer .tab-button').forEach((btn, i) => btn.classList.toggle('active', i === currentDatasetIndex));
    }

    function setupEventListeners() {
      overlayVideo.addEventListener('canplay', () => {
        if (overlayVideo.error) return;
        playBtn.textContent = overlayVideo.paused ? 'Play' : 'Pause';
        playBtn.disabled = false;
      });
      overlayVideo.addEventListener('playing', () => {
          if (overlayVideo.error) return;
          playing = true; playBtn.textContent = 'Pause'; playBtn.disabled = false;
      });
      overlayVideo.addEventListener('pause', () => {
          if (overlayVideo.error) return;
          playing = false; playBtn.textContent = 'Play'; playBtn.disabled = false;
      });
      overlayVideo.addEventListener('ended', () => {
        if (overlayVideo.error) return;
        playing = false; playBtn.textContent = 'Play';
      });
      overlayVideo.addEventListener('seeked', () => {
          if (overlayVideo.error) return;
          simTimeAbs = overlayVideo.currentTime; frameIdx = 0;
          if (overlayVideo.paused) { playing = false; playBtn.textContent = 'Play'; playBtn.disabled = false; }
          if (!slider.matches(':active')) slider.value = simDuration > 0 ? simTimeAbs / simDuration : 0;
          updateSceneObjects(simTimeAbs);
      });
      overlayVideo.addEventListener('error', e => {
        console.error('Video ERROR event:', e);
        let errorMsg = 'Video Error';
        if (overlayVideo.error) {
             switch (overlayVideo.error.code) {
                case MediaError.MEDIA_ERR_ABORTED: errorMsg = 'Vid Load Aborted'; break;
                case MediaError.MEDIA_ERR_NETWORK: errorMsg = 'Vid Network Err'; break;
                case MediaError.MEDIA_ERR_DECODE: errorMsg = 'Vid Decode Err'; break;
                case MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED: errorMsg = 'Vid Format Err'; break;
                default: errorMsg = 'Vid Unknown Err';
            }
        }
        playBtn.textContent = errorMsg; playBtn.disabled = true; playing = false;
      });
      playBtn.addEventListener('click', () => {
        if (playBtn.disabled || overlayVideo.error) return;
        playBtn.disabled = true;
        if (overlayVideo.paused) {
          overlayVideo.play().catch(e => {
            console.error("video.play() rejected:", e);
            playBtn.disabled = false; playBtn.textContent = 'Play'; playing = false;
          });
        } else {
          overlayVideo.pause();
          // Manually enable button and set text, as pause event might be delayed
          playBtn.disabled = false; playBtn.textContent = 'Play'; playing = false;
        }
      });
      slider.addEventListener('input', () => {
        if (overlayVideo.error || !isFinite(simDuration) || simDuration <= 0) return;
        const targetVideoTime = parseFloat(slider.value) * simDuration;
        if (Math.abs(targetVideoTime - overlayVideo.currentTime) > 0.05) { // Only seek if significant change
            const wasPlaying = !overlayVideo.paused;
            if (wasPlaying) overlayVideo.pause();

            overlayVideo.currentTime = Math.max(0, Math.min(targetVideoTime, simDuration - 0.01));
            // The 'seeked' event will handle UI updates for slider and playing state
        }
      });
    }

    function generateTabs() {
        tabsContainer.innerHTML = '';
        datasets.forEach((dataset, index) => {
            const button = document.createElement('button');
            button.classList.add('tab-button');
            button.textContent = dataset.name;
            button.dataset.index = index;
            if (index === currentDatasetIndex) button.classList.add('active');
            button.addEventListener('click', () => {
                if (index !== currentDatasetIndex && !playBtn.disabled) loadDataset(index);
            });
            tabsContainer.appendChild(button);
        });
    }

    function updateSceneObjects(currentSimTime) {
        if (timesArr.length > 0) {
            if (frameIdx > 0 && currentSimTime < timesArr[frameIdx]) frameIdx = 0;
            while (frameIdx < timesArr.length - 1 && currentSimTime >= timesArr[frameIdx + 1]) frameIdx++;
        } else { frameIdx = 0; }

        const frameData = (timesArr.length > 0 && simMap.has(timesArr[frameIdx])) ? simMap.get(timesArr[frameIdx]) : [];
        const presentIds = new Set();
        if (Array.isArray(frameData)) frameData.forEach((o,i) => presentIds.add(o.id !== undefined ? String(o.id) : String(i)));

        for (let id of cars.keys()) {
            if (!presentIds.has(id)) {
                const carEntry = cars.get(id);
                if (carEntry && carEntry.mesh) {
                    carEntry.mesh.traverse(child => {
                        if (child.isMesh && child.material && child.material.userData.isDynamicColor) child.material.dispose();
                    });
                    scene.remove(carEntry.mesh);
                }
                cars.delete(id);
            }
        }

        if (Array.isArray(frameData) && modelAssets.size > 0) {
            frameData.forEach((o,i) => {
                const id = o.id !== undefined ? String(o.id) : String(i);
                const type = o.type || 'Car';
                const asset = modelAssets.get(type);
                if (!asset) { if (cars.has(id)) { scene.remove(cars.get(id).mesh); cars.delete(id); } return; }
                if (![o.x, o.y, o.z, o.rotation_y].every(val => typeof val === 'number' && isFinite(val))) {
                    if (cars.has(id)) { scene.remove(cars.get(id).mesh); cars.delete(id); } return;
                }

                const yPos = o.y + asset.baseOffsetY + asset.verticalOffset;
                const xPos = -o.x, zPos = o.z, yaw = o.rotation_y;
                let carEntry = cars.get(id);
                const objectColorRGB = o.color;
                let newColorStr = "gltf_default";
                if (Array.isArray(objectColorRGB) && objectColorRGB.length === 3) newColorStr = `rgb(${objectColorRGB.join(',')})`;

                if (carEntry && carEntry.type !== type) {
                     carEntry.mesh.traverse(child => { if (child.isMesh && child.material && child.material.userData.isDynamicColor) child.material.dispose(); });
                    scene.remove(carEntry.mesh); cars.delete(id); carEntry = null;
                }

                if (!carEntry) {
                    const newMesh = asset.proto.clone(true);
                    if (Array.isArray(objectColorRGB) && objectColorRGB.length === 3) {
                        const newMaterial = new THREE.MeshStandardMaterial({ color: new THREE.Color(...objectColorRGB.map(c=>c/255)), metalness: 0.4, roughness: 0.6 });
                        newMaterial.userData.isDynamicColor = true;
                        newMesh.traverse(n => { if (n.isMesh) n.material = newMaterial; });
                    }
                    newMesh.traverse(n => { if (n.isMesh) { n.castShadow = true; n.receiveShadow = true; }});
                    scene.add(newMesh);
                    carEntry = { mesh: newMesh, type: type, currentColorStr: newColorStr };
                    cars.set(id, carEntry);
                } else {
                    if (carEntry.currentColorStr !== newColorStr) {
                        carEntry.mesh.traverse(child => { if (child.isMesh && child.material && child.material.userData.isDynamicColor) child.material.dispose(); });
                        if (Array.isArray(objectColorRGB) && objectColorRGB.length === 3) {
                            const updatedMaterial = new THREE.MeshStandardMaterial({ color: new THREE.Color(...objectColorRGB.map(c=>c/255)), metalness: 0.4, roughness: 0.6 });
                            updatedMaterial.userData.isDynamicColor = true;
                            carEntry.mesh.traverse(n => { if (n.isMesh) n.material = updatedMaterial; });
                        } else {
                            const originalProtoMesh = asset.proto.clone(true);
                            carEntry.mesh.traverse(n => {
                               if (n.isMesh) {
                                   const correspondingProtoNode = originalProtoMesh.getObjectByProperty('uuid', n.uuid) || originalProtoMesh.getObjectByName(n.name);
                                   n.material = (correspondingProtoNode && correspondingProtoNode.isMesh) ? correspondingProtoNode.material : plainMat.clone();
                               }
                            });
                        }
                        carEntry.currentColorStr = newColorStr;
                    }
                }
                carEntry.mesh.position.set(xPos, yPos, zPos);
                carEntry.mesh.rotation.set(0, (2 * Math.PI - yaw) + asset.rotationYOffset, 0);
            });
        }
    }

    function animate() {
      requestAnimationFrame(animate);
      if (playing) simTimeAbs = overlayVideo.currentTime;
      if (isFinite(simDuration) && simDuration > 0 && !slider.matches(':active')) {
          slider.value = simTimeAbs / simDuration;
      } else if ((!isFinite(simDuration) || simDuration <= 0) && !slider.matches(':active')) {
          slider.value = 0;
      }
      updateSceneObjects(simTimeAbs);
      if (orbitControls) orbitControls.update();
      if (renderer && scene && camera) renderer.render(scene, camera);
    }

    async function main() {
      console.log('main() CALLED');
      playBtn.disabled = true; playBtn.textContent = 'Loading...';
      const threeJsReady = await setupThreeJSBase();
      if (!threeJsReady) { playBtn.textContent = '3D Error'; return; }
      generateTabs();
      setupEventListeners();
      await loadDataset(currentDatasetIndex);
    }

    main().catch(err => {
        console.error("CRITICAL FAILURE in main():", err);
        if (canvasContainer) canvasContainer.innerHTML = `<p style="color: red; padding: 20px;">Critical script error: ${err.message}.</p>`;
        if (playBtn) { playBtn.textContent = 'Fatal Error'; playBtn.disabled = true; }
    });
  </script>
</body>
</html>
